# 📚 Third-Order Letter Approximation & ELIZA Chatbot Project

Welcome to the **Third-Order Letter Approximation & ELIZA Chatbot** project! This repository encompasses tasks ranging from text analysis using trigram models to building a classic ELIZA chatbot interface. Dive in to explore the functionalities and contributions of each component.

---

## 📜 Table of Contents

- [📚 Third-Order Letter Approximation & ELIZA Chatbot Project](#-third-order-letter-approximation--eliza-chatbot-project)
  - [📋 Tasks Overview](#-tasks-overview)
    - [🔍 Task 1: Third-Order Letter Approximation Model](#-task-1-third-order-letter-approximation-model)
    - [✍️ Task 2: Third-Order Letter Approximation Generation](#️-task-2-third-order-letter-approximation-generation)
    - [📈 Task 3: Analyze Your Model](#-task-3-analyze-your-model)
    - [💾 Task 4: Export Model as JSON File](#-task-4-export-model-as-json-file)
  - [🤖 ELIZA Chatbot](#-eliza-chatbot)
    - [🔧 Project Structure](#-project-structure)
    - [✨ Features](#-features)
    - [🚀 Usage](#-usage)
    - [📂 Code Overview](#-code-overview)
  - [📁 File Structure](#-file-structure)
  - [🔗 License](#-license)
  - [🙌 Contributing](#-contributing)
  - [📞 Contact](#-contact)

---

## 📋 Tasks Overview

### 🔍 Task 1: Third-Order Letter Approximation Model

#### **Overview**
Implement a **third-order letter approximation model** that analyzes five plain-text works from Project Gutenberg. This model counts the occurrences of every three-character sequence (trigram) in the cleaned text, providing insights into the frequency of specific letter sequences.

#### **Project Gutenberg Works**
- **Selection Criteria:**
  - Plain Text UTF-8 format.
  - Contains only ASCII characters: letters, spaces, and full stops.
- **File Naming:** `file1`, `file2`, `file3`, `file4`, `file5` for streamlined usage.

#### **Function Descriptions**

1. **`load_and_clean_text(file_paths)`**
   - **Purpose:** Loads multiple text files, removes unwanted characters, and converts all characters to uppercase.
   - **Parameters:**
     - `file_paths` (List[str]): Paths to the Project Gutenberg text files.
   - **Returns:** `str` – A cleaned string ready for trigram analysis.

2. **`generate_trigrams(text)`**
   - **Purpose:** Creates a trigram model by counting every three-character sequence in the cleaned text.
   - **Parameters:**
     - `text` (str): Cleaned text for trigram extraction.
   - **Returns:** `Dict[str, int]` – Dictionary with trigrams as keys and their counts as values.

3. **`display_top_trigrams(trigram_counts, n=100)`**
   - **Purpose:** Displays the top `n` most frequent trigrams.
   - **Parameters:**
     - `trigram_counts` (Dict[str, int]): Trigram frequency dictionary.
     - `n` (int, optional): Number of top trigrams to display. *(Default: 100)*
   - **Displays:** Top `n` trigrams directly in the console.

---

### ✍️ Task 2: Third-Order Letter Approximation Generation

#### **Overview**
Extend the trigram model from Task 1 to generate a 10,000-character-long string. The model predicts the next character based on the frequency of trigrams, following the patterns identified in the cleaned text.

#### **Function Descriptions**

1. **`generate_next_char(trigram_counts, prev_two_chars)`**
   - **Purpose:** Predicts the next character based on the previous two characters using the trigram model.
   - **Parameters:**
     - `trigram_counts` (Dict[str, int]): Trigram frequencies from Task 1.
     - `prev_two_chars` (str): The preceding two characters in the current sequence.
   - **Returns:** `str` – The predicted next character.

2. **`generate_text(trigram_counts, length=10000)`**
   - **Purpose:** Generates a lengthy string by iteratively predicting the next character.
   - **Parameters:**
     - `trigram_counts` (Dict[str, int]): Trigram frequency dictionary.
     - `length` (int, optional): Desired length of the generated text. *(Default: 10,000 characters)*
   - **Returns:** `str` – Generated text of specified length.

---

### 📈 Task 3: Analyze Your Model

#### **Overview**
Assess the quality of the generated text by calculating the percentage of valid English words. This analysis provides insight into the model's ability to produce coherent language sequences.

#### **Function Descriptions**

1. **`load_word_list(file_path)`**
   - **Purpose:** Loads a list of valid English words from a specified file.
   - **Parameters:**
     - `file_path` (str): Path to `words.txt`, containing valid English words.
   - **Returns:** `Set[str]` – Set of uppercase English words.

2. **`calculate_percentage_of_real_words(generated_text, valid_words)`**
   - **Purpose:** Calculates the percentage of valid English words in the generated text.
   - **Parameters:**
     - `generated_text` (str): Text generated by the trigram model.
     - `valid_words` (Set[str]): Set of valid English words.
   - **Returns:** `float` – Percentage of valid English words in the generated text.

---

### 💾 Task 4: Export Model as JSON File

#### **Overview**
Export the trigram model created in Task 1 to a JSON file. This enables future access to the model data or integration with other projects.

#### **Function Description**

- **`export_trigram_model_to_json(trigram_counts, filename='trigram.json')`**
  - **Purpose:** Exports the trigram model to a JSON file.
  - **Parameters:**
    - `trigram_counts` (Dict[str, int]): Trigram model to export.
    - `filename` (str, optional): Name of the JSON file. *(Default: `trigram.json`)*
  - **Result:** Trigram model saved as a JSON file in the specified location.

---

# 🤖 ELIZA Chatbot

## **Overview**
The **ELIZA Chatbot** is a web-based conversational program inspired by Joseph Weizenbaum's early natural language processing model. It simulates human-like conversation by analyzing user input and responding with dynamic, pre-programmed responses.

This project includes:
- A stylish, responsive interface.
- Regex-based input parsing.
- Context-aware responses for a more interactive experience.

---

## 🔧 **Project Structure**

### **File Breakdown**
1. **`index.html`**
   - Defines the chatbot's structure and layout.
2. **`eliza.js`**
   - Contains the logic for input processing, response generation, and sentiment detection.
3. **`style.css`**
   - Provides the styling for the interface, animations, and overall design.

### **Features**
- **Dynamic Sentiment Analysis**
- **Synonym Recognition**
- **Interactive Conversations**
- **Contextual Memory** (Tracks user name and emotional state)
- **Mobile-Friendly Design**

---

## 🚀 **How to Use**
1. **Start the Chatbot**  
   Open `index.html` in any browser to launch the chatbot interface.

2. **Type a Message**  
   Interact by typing your message in the input box and pressing Enter or clicking the send button.

3. **Reset the Chat**  
   Clear the chat history using the Reset button in the header.

---

## 🛠️ **Feature Testing Guide**

Here’s how you can test each feature of the chatbot:

### 1. **Sentiment Detection**
   - **Positive Sentiment:**  
     Type: `I am happy`  
     Expected Response: *"That's wonderful! What's contributing to your positive feelings?"*
   - **Negative Sentiment:**  
     Type: `I am sad`  
     Expected Response: *"I'm sorry to hear that. Would you like to talk about what's making you feel this way?"*
   - **Neutral Sentiment:**  
     Type: `I am okay`  
     Expected Response: *"I see. Is there anything you'd like to talk about?"*

### 2. **Synonym Recognition**
   - **Synonym for Greeting:**  
     Type: `Hey`  
     Expected Response: *"Hello! How are you feeling today?"*
   - **Synonym for Sadness:**  
     Type: `I feel blue`  
     Expected Response: *"I'm sorry to hear that. Would you like to talk about what's making you feel this way?"*

### 3. **Contextual Memory**
   - **Provide Name:**  
     Type: `My name is Alex`  
     Expected Response: *"It's a pleasure to meet you, Alex. How has your day been so far?"*
   - **Emotion Tracking:**  
     After typing `I am excited`, type `Why do I feel like this?`  
     Expected Response: *"Let's explore why you feel that way."*

### 4. **Dynamic Response Patterns**
   - **Ask for Time:**  
     Type: `What time is it?`  
     Expected Response: *"The current time is HH:MM AM/PM."*
   - **Ask for Date:**  
     Type: `What's today's date?`  
     Expected Response: *"Today's date is MM/DD/YYYY."*

### 5. **Conversation Flow**
   - **Ask Open-ended Questions:**  
     Type: `Why is the sky blue?`  
     Expected Response: *"What are your thoughts on why the sky is blue?"*
   - **Mention a Goal:**  
     Type: `I want to learn coding`  
     Expected Response: *"What steps do you think you can take toward achieving 'learn coding'?"*

### 6. **Default Response**
   - **Unrecognized Input:**  
     Type: `asdjhasjdh`  
     Expected Response: *"Please, tell me more about that."*

### 7. **Reset Chat**
   - **Clear the Conversation:**  
     Click the Reset button in the header.  
     Expected Behavior: The chat history should clear, and you can start a new conversation.

---

## ✨ **Design Features**
- **Glassmorphism UI:**  
  The interface uses a modern glass-like aesthetic for an immersive user experience.
- **Responsive Layout:**  
  Designed to adapt seamlessly across desktop and mobile devices.
- **Typing Indicator:**  
  A visual indicator displays when ELIZA is generating a response.

---

## 🛠️ **Technical Details**
- **Programming Language:** JavaScript
- **Styling:** CSS with animations and transitions
- **Core Logic:** Regex pattern matching and dynamic function calls for response generation

---

## 📂 **Code Highlights**

### Response Matching
Regex-based matching identifies key patterns in user input to trigger appropriate responses:
```javascript
{
    pattern: /\bhello\b|hi|hey|greetings/i,
    response: [
        "Hello! How are you feeling today?",
        "Hi there! What's on your mind?",
        "Hey! How can I assist you?"
    ]
}


